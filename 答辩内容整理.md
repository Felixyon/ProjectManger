## 答辩内容整理

#### 1.技术支撑

* 数据层
  * MySQL（以表结构存储）
  * druid数据连接池（同时加载多个connecttion，保证需要connecttion的时候，可以直接拿到，connecttion是直接构建sqlstatement的实现类）
  * MyBatis：相当于一个ORM映射框架+数据缓存池（redis）。ORM是将在JAVA里面建的实体类POJO类，有了MyBatis之后，只需要操作Java中的实体，不需要再对数据库中的表进行直接操作。数据的持久化。DB是有瓶颈的，击穿缓存会造成很大的事故。
* 业务层
  * 组织关系，将前端的请求转化为后面实体类的关系、数据变化
  * SpringMVC框架，Controller（处理接受请求，使用RestFul格式开发），Service（实际业务的实现）；plugins：jackson（将java的实体类或者arraylist转化为JSON格式发送到前端，便于前端进行数据解析，开发调用）；filter进行编码过滤，避免出现乱码;
  * 使用SpringMvc的原因是，依赖倒转、依赖注入；在web工程开发时，往往需要建立很多的工具类对于各种请求进行处理，工具类使用时，往往会实例化占用资源，我们很难做到及时将这些工具类初始化或释放，这就造成了很多资源上的浪费。使用SpringMvc，依赖注入，就可以不写工具类，只写工具类的接口，和接口的实现，由SpringMvc框架，来自动将接口转化为实体类，并初始化和实例释放，减少了编写难度。
  * 举例子:注册了两个用户，使两个用户之间建立关系，加入一个workgroup。实际上，就是将用户的信息变化映射到实体上的变化，由数据层映射到实际上数据库的增删改查。
  * 申报一个新的项目->新建一个项目实体，项目实体填充属性：项目申请人，项目申请名称，项目申请表，申请时间，附件;新建管理员事务实体（相当于向管理员事务表查了一条数据，管理员上线即可查看);新建消息实体，管理员的和申请人的->管理员审核:新建workgroup实体列表，并将申请人添加到workgroup实体列表里面；发送消息；
* 交互层
  * Bootstrap+Javascript+Jquery
  * 路由实现，router.js来实现路由
  * 跨页面传参：
    * 1.url传参，通过解析url来获取参数
    * 2.LocalStorage，将需要的数据存储到LocalStorage里面，需要时，取出来进行解析
    * 举例：用户登录信息，可以将用户信息存到本地，跨页面进行操作时，初始化页面读取该信息填充到页面里，依然保留登陆状态。
  * 前后端数据交互：使用了Jquery的ajax，数据进行异步加载。异步加载的原因是，只要请求过来数据，立即将数据渲染到视图层，避免因为某些网络原因，使得整个页面无法正常阅读的情况。
  * 找回密码：根据前端确认后无误的用户名，向后端请求找回密码。后端实际操作是，先通过确认该用户存在，然后就向该用户的邮箱使用pop3组件发送一条重置密码的链接，重置密码是单独页面，会有时间为1h有效期的uuid作为参数加在重置密码链接里面。用户在接收到这个信息之后，打开链接，即可输入密码，后端根据uuid和密码进行更新。

### 2.具体实现



### 3.功能亮点

* 可拖拽的项目看板；（前端：dragable-portlet实现拖拽,drapable-box作为拖拽框的存储区,读取dragablebox里面的class数量来确认拖拽变化;后端：增删改查;）
* 为了方便用户，功能的组织很简洁。直接登陆后，就可以看到目前正在进行的工作组发的项目通知和项目工作台的工作看板，和默认工作组的留言板，和最新的学校信息通知。



### 4.不足与总结

* 前端没有使用单页面的框架，比如vue和react，将功能封装成为模块，前端性能还可以进一步优化
* 后端没有使用spring boot+spring cloud的RPC框架开发模式，如果做成微服务的模式，就可以应对极高的并发环境。
* 技术还是不足，在写到现在这种样子，花费了几个月的时间